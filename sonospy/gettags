#!/usr/bin/env python

# gettags
#
# gettags copyright (c) 2010-2011 Mark Henkelis
# mutagen copyright (c) 2005 Joe Wreschnig, Michael Urman (mutagen is Licensed under GPL version 2.0)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Mark Henkelis <mark.henkelis@tesco.net>

import os, sys
import locale
import time

import hashlib
import sqlite3
import optparse
import ConfigParser

import mutagen
from mutagen import File
from mutagen.asf import ASFUnicodeAttribute     # seems to be an issue with multiple tag entries in wma files

MULTI_SEPARATOR = '\n'
fileexclusions = ['.ds_store', 'desktop.ini', 'thumbs.db']
artextns = ['.jpg', '.bmp', '.png', '.gif']
#enc = locale.getpreferredencoding()
enc = sys.getfilesystemencoding()

# get ini settings
config = ConfigParser.ConfigParser()
config.optionxform = str
config.read('scan.ini')
# multi-field separator
linux_file_modification_time = 'mtime'
try:        
    linux_file_modification_time = config.get('gettags', 'linux_file_modification_time')
except ConfigParser.NoSectionError:
    pass
except ConfigParser.NoOptionError:
    pass
linux_file_creation_time = ''
try:        
    linux_file_creation_time = config.get('gettags', 'linux_file_creation_time')
except ConfigParser.NoSectionError:
    pass
except ConfigParser.NoOptionError:
    pass

'''
For the path supplied
    For every new file encountered
        a new record is written to tags
        a blank record is written to tags_update (I, 0)
        a copy of the inserted record is written to tags_update (I, 1)
    For every existing file encountered
        if there are no changes
            the scannumber in tags is updated (so that any files not
            encountered can be flagged later)
        else
            a copy of the old record is written to tags_update (U, 0)
            a copy of the new record is written to tags_update (U, 1)
    For every existing record where no file is encountered
        the old record is written to tags_update (D, 0)
        a blank record is written to tags_update (D, 1)

When processing tags subsequently, select from tags_update on scannumber 
    the update type is on both records
    record 0 is the before image, record 1 the after image
'''

def process_dir(scanpath, options, database):

    if not options.quiet:
        print "Scanning: %s" % scanpath.encode(enc, 'replace')
    if options.database:
        db = sqlite3.connect(database)
#        db.execute("PRAGMA synchronous = 0;")
        c = db.cursor()

        db2 = sqlite3.connect(database)
        c2 = db2.cursor()
        
        c.execute('''insert into scans values (?,?)''', (None, scanpath))
        scannumber = c.lastrowid
        if not options.quiet:
            print "Scannumber: %d" % scannumber

    processing_count = 1

    for filepath, dirs, files in os.walk(scanpath):

        filepath = filepath.decode(enc, 'replace')
        dirs = [d.decode(enc, 'replace') for d in dirs]
        files = [f.decode(enc, 'replace') for f in files]
        
        dont_process = False
        if options.exclude:
            for ex in options.exclude:
                if ex in filepath:
                    dont_process = True
        if dont_process:
            continue
        
        files.sort()
        
        folderart = get_folderart(files)
        if folderart:
            folderart = os.path.join(filepath, folderart)
        
        for fn in files:
            if fn.lower() in fileexclusions: continue
            ff, ex = os.path.splitext(fn)
            if ex.lower() in artextns: continue
            ffn = os.path.join(filepath, fn)
            if not os.access(ffn, os.R_OK): continue
            try:
                if options.verbose:
                    out = "processing file: " + str(processing_count) + "\r" 
                    sys.stderr.write(out)
                    sys.stderr.flush()
                    processing_count += 1

                fstat = os.stat(ffn)
                fsize = unicode(fstat.st_size)
                fctime = unicode(fstat.st_ctime)
                fmtime = unicode(fstat.st_mtime)
                fatime = unicode(fstat.st_atime)

                if linux_file_modification_time == 'ctime' and os.name != 'nt':
                    created = fmtime
                    lastmodified = fctime
                elif linux_file_creation_time == 'atime' and os.name != 'nt':
                    created = fatime
                    lastmodified = fmtime
                elif os.name == 'nt':
                    created = fctime
                    lastmodified = fmtime
                elif os.name != 'nt':
                    created = ''
                    lastmodified = fmtime
                
                get_tags = True
                if options.database:
                    # don't process file if it hasn't changed, unless art has been added/changed
                    try:
                        c.execute("""select created, lastmodified, folderart from tags where path=? and filename=?""",
                                    (filepath, fn))
                        row = c.fetchone()
                        if row:
                            create, lastmod, art = row
                            if create == created and lastmod == lastmodified and art == folderart:
                                get_tags = False
                    except sqlite3.Error, e:
                        print "Error checking file created:", e.args[0]

                if get_tags:                    
                
                    kind = File(ffn, easy=True)
                    tags = {}
                    trackart = None

                    if isinstance(kind, mutagen.flac.FLAC):
                        if len(kind.pictures) > 0:
                            trackart_offset, trackart_length = kind.find_picture_offset()
                            trackart = 'EMBEDDED_%s,%s' % (trackart_offset, trackart_length)
                        if kind.tags:
                            tags.update(kind.tags)
                        # assume these attributes exist (note these will overwrite kind.tags)
                        tags['type'] = 'FLAC'
                        tags['length'] = kind.info.length               # seconds
                        tags['sample_rate'] = kind.info.sample_rate     # Hz
                        tags['bits_per_sample'] = kind.info.bits_per_sample     # bps
                        tags['channels'] = kind.info.channels
                        tags['mime'] = kind.mime[0]

                    elif isinstance(kind, mutagen.mp3.EasyMP3):
                        if kind.tags:
                            picture, trackart_offset, trackart_length = kind.ID3.getpicture(kind.tags)
                            if picture:
                                trackart = 'EMBEDDED_%s,%s' % (trackart_offset, trackart_length)
                            tags.update(kind.tags)
                            if 'performer' in tags:
                                tags['albumartist'] = tags['performer']

                        # assume these attributes exist (note these will overwrite kind.tags)
                        tags['type'] = 'MPEG %s layer %d' % (kind.info.version, kind.info.layer)
                        tags['length'] = kind.info.length               # seconds
                        tags['sample_rate'] = kind.info.sample_rate     # Hz
                        tags['bitrate'] = kind.info.bitrate             # bps
                        tags['mime'] = kind.mime[0]

#                    elif isinstance(kind, mutagen.easymp4.EasyMP4):
#                        if kind.tags:
#                            tags.update(kind.tags)
#                        # assume these attributes exist (note these will overwrite kind.tags)
#                        tags['type'] = 'MPEG-4 audio'
#                        tags['length'] = kind.info.length               # seconds
#                        tags['sample_rate'] = kind.info.sample_rate     # Hz
#                        tags['bits_per_sample'] = kind.info.bits_per_sample     # bps
#                        tags['channels'] = kind.info.channels
#                        tags['bitrate'] = kind.info.bitrate             # bps
#                        tags['mime'] = kind.mime[0]

                    elif isinstance(kind, mutagen.asf.ASF):
                        picture, trackart_offset, trackart_length = kind.get_picture()
                        if picture:
                            trackart = 'EMBEDDED_%s,%s' % (trackart_offset, trackart_length)
                        # WMA
                        if kind.tags:
                            if u'WM/AlbumTitle' in kind.tags: tags['album'] = [v.__str__() for v in kind.tags[u'WM/AlbumTitle']]
                            if u'WM/AlbumArtist' in kind.tags: tags['albumartist'] = [v.__str__() for v in kind.tags[u'WM/AlbumArtist']]
                            if 'Author' in kind.tags: tags['artist'] = [v for v in encodeunicode(kind.tags['Author'])]
                            if 'Title' in kind.tags: tags['title'] = [v for v in encodeunicode(kind.tags['Title'])]
                            if u'WM/Genre' in kind.tags: tags['genre'] = [v.__str__() for v in kind.tags[u'WM/Genre']]
                            if u'WM/TrackNumber' in kind.tags: tags['tracknumber'] = [v.__str__() for v in kind.tags[u'WM/TrackNumber']]
                            if u'WM/Year' in kind.tags: tags['date'] = [v.__str__() for v in kind.tags[u'WM/Year']]
                        # assume these attributes exist (note these will overwrite kind.tags)
                        tags['type'] = 'Windows Media Audio'
                        tags['length'] = kind.info.length               # seconds
                        tags['sample_rate'] = kind.info.sample_rate     # Hz
                        tags['channels'] = kind.info.channels
                        tags['bitrate'] = kind.info.bitrate             # bps
                        tags['mime'] = kind.mime[0]

                    elif isinstance(kind, mutagen.oggvorbis.OggVorbis):
                        if kind.tags.sections:
                            sections = ','.join(str(s) for s in kind.tags.sections)
                            sections += ',base64flac'
                            trackart = 'EMBEDDED_%s' % sections
                            kind.tags['metadata_block_picture'] = 'removed'     # remove from tags as not needed
                        if kind.tags:
                            tags.update(kind.tags)
                        # assume these attributes exist (note these will overwrite kind.tags)
                        tags['type'] = 'Ogg Vorbis'
                        tags['length'] = kind.info.length               # seconds
                        tags['sample_rate'] = kind.info.sample_rate     # Hz
                        tags['bitrate'] = kind.info.bitrate             # bps
                        tags['mime'] = kind.mime[0]

                    else:
                        if options.verbose:
                            print "Filetype not catered for: %s" % (ffn.encode(enc, 'replace'))
                        
                    if tags:
                        if options.verbose:
                            print tags

#                        print "==========================================="
#                        print "artists: %s" % tags.get('artist', '')
#                        print "albumartists: %s" % tags.get('albumartist', '')
#                        print "composers: %s" % tags.get('composer', '')
#                        print "==========================================="

                        if options.database:
                            title = MULTI_SEPARATOR.join(tags.get('title', ''))
                            artist = MULTI_SEPARATOR.join(tags.get('artist', ''))
                            album = MULTI_SEPARATOR.join(tags.get('album', ''))
                            genre = MULTI_SEPARATOR.join(tags.get('genre', ''))
                            track = MULTI_SEPARATOR.join(tags.get('tracknumber', ''))
                            year = MULTI_SEPARATOR.join(tags.get('date', ''))
                            albumartist = MULTI_SEPARATOR.join(tags.get('albumartist', ''))
                            composer = MULTI_SEPARATOR.join(tags.get('composer', ''))
                            codec = tags['type']
                            length = int(tags['length'])
                            size = fsize
                            path = filepath
                            filename = fn
                            discnumber = MULTI_SEPARATOR.join(tags.get('discnumber', ''))
                            comment = MULTI_SEPARATOR.join(tags.get('comment', ''))
                            folderart = folderart
                            if trackart:
                                trackspec = os.path.join(path, filename)
                                trackart = '%s_%s' % (trackart, trackspec)         
                            arts = []
                            if folderart:
                                arts.append(folderart)
                            if trackart:
                                arts.append(trackspec)
                            ids = []
                            for artspec in arts:
                                # get unique id for album art
                                artid = None
                                try:
                                    c.execute("""select id, artpath from art where artpath=?""",
                                                (artspec, ))
                                    row = c.fetchone()
                                    if row:
                                        artid, artpath = row
                                    else:
                                        c.execute('''insert into art values (?,?)''', (None, artspec))
                                        artid = c.lastrowid
                                except sqlite3.Error, e:
                                    print "Error checking/inserting art:", e.args[0]
                                ids.append(artid)
                            trackartid = None
                            if trackart:
                                trackartid = ids.pop()
                            folderartid = None
                            if folderart:
                                folderartid = ids.pop()
                            bitrate = tags['bitrate'] if 'bitrate' in tags.keys() else ''
                            bitspersample = tags['bits_per_sample'] if 'bits_per_sample' in tags.keys() else ''
                            channels = tags['channels'] if 'channels' in tags.keys() else ''
                            samplerate = tags['sample_rate'] if 'sample_rate' in tags.keys() else ''
                            mime = tags['mime']
                            upnpclass = 'object.item.audioItem.musicTrack'
                
                currenttime = time.time()
                inserted = currenttime
                lastscanned = currenttime

                # if we didn't get tags, nothing has changed so we just want to update the scannumber to show we processed the file
                # (record must exist as we found it earlier)
                if not get_tags:
                    try:
                        tags = (scannumber, lastscanned,
                                filepath, fn)
                        if options.verbose:
                            print "UPDATE SCAN DETAILS: " + str(tags)
                        c.execute("""update tags set
                                     scannumber=?, lastscanned=? 
                                     where path=? and filename=?""", 
                                     tags)
                    except sqlite3.Error, e:
                        print "Error updating file scan details:", e.args[0]
                else:
                    # if we can process this filetype
                    if tags:
                        # we got tags as either:
                        #   the file timestamp changed (so the record exists)
                        #   the cover changed (so the record exists)
                        #   it's a new file (so the record doesn't exist)
                        try:
                            # get the existing record for this unique path/filename if it exists
                            c.execute("""select * from tags where path=? and filename=?""", (path, filename))
                            crow = c.fetchone()
                            if not crow:
                                # this track did not previously exist, create a tags record
                                
                                filespec = os.path.join(path, filename)
                                filespec = filespec.encode(enc, 'replace')
                                mf = hashlib.md5()
                                mf.update(filespec)
                                fid = mf.hexdigest()

                                tagspec = title + album + artist + track
                                tagspec = tagspec.encode(enc, 'replace')
                                mt = hashlib.md5()
                                mt.update(tagspec)
                                tid = mt.hexdigest()
                                
                                tags = (fid, tid,
                                        title, artist, album,
                                        genre, str(track), year,
                                        albumartist, composer, codec, 
                                        length, size, 
                                        created, path, filename, 
                                        discnumber, comment, 
                                        folderart, trackart,
                                        bitrate, samplerate, 
                                        bitspersample, channels, mime, 
                                        lastmodified, upnpclass, scannumber,
                                        folderartid, trackartid,
                                        inserted, lastscanned)
                                if not options.quiet:
                                    print "New file found: %s, %s" % (filename.encode(enc, 'replace'), path.encode(enc, 'replace'))
                                if options.verbose:
                                    print "INSERT: " + str(tags)
                                c.execute("""insert into tags values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""", tags)
                                # create audit records
                                # pre
                                itags = cleartags(tags)
                                itags += (0, 'I')
                                c.execute("""insert into tags_update values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""", itags)
                                # post
                                tags += (1, 'I')
                                c.execute("""insert into tags_update values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""", tags)
                            else:
                                # track exists, get data
                                o_id, o_id2, o_title, o_artist, o_album, \
                                o_genre, o_track, o_year, \
                                o_albumartist, o_composer, o_codec,  \
                                o_length, o_size,  \
                                o_created, o_path, o_filename,  \
                                o_discnumber, o_comment,  \
                                o_folderart, o_trackart,  \
                                o_bitrate, o_samplerate, \
                                o_bitspersample, o_channels, o_mime, \
                                o_lastmodified, o_upnpclass, o_scannumber,  \
                                o_folderartid, o_trackartid,  \
                                o_inserted, o_lastscanned = crow

                                # at this point something has been updated:
                                # create audit records
                                # pre
                                tags = (o_id, o_id2,
                                        o_title, o_artist, o_album,
                                        o_genre, o_track, o_year,
                                        o_albumartist, o_composer, o_codec, 
                                        o_length, o_size, 
                                        o_created, o_path, o_filename, 
                                        o_discnumber, o_comment, 
                                        o_folderart, o_trackart, 
                                        o_bitrate, o_samplerate, 
                                        o_bitspersample, o_channels, o_mime, 
                                        o_lastmodified, o_upnpclass, scannumber,
                                        o_folderartid, o_trackartid,
                                        o_inserted, o_lastscanned)
                                tags += (0, 'U')
                                c.execute("""insert into tags_update values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""", tags)
                                # create new id2 in case attribs have changed
                                tagspec = title + album + artist + track
                                tagspec = tagspec.encode(enc, 'replace')
                                mt = hashlib.md5()
                                mt.update(tagspec)
                                tid = mt.hexdigest()
                                # post
                                tags = (o_id, tid,
                                        title, artist, album,
                                        genre, str(track), year,
                                        albumartist, composer, codec, 
                                        length, size, 
                                        created, path, filename,
                                        discnumber, comment,
                                        folderart, trackart, 
                                        bitrate, samplerate, 
                                        bitspersample, channels, mime, 
                                        lastmodified, o_upnpclass, scannumber, 
                                        folderartid, trackartid,
                                        o_inserted, lastscanned)
                                tags += (1, 'U')
                                c.execute("""insert into tags_update values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""", tags)
                                # now update the existing record
                                tags = (tid, title, artist, album,
                                        genre, str(track), year,
                                        albumartist, composer, codec, 
                                        length, size, 
                                        created, 
                                        discnumber, comment,
                                        folderart, trackart, 
                                        bitrate, samplerate, 
                                        bitspersample, channels, mime, 
                                        lastmodified, scannumber,
                                        folderartid, trackartid,
                                        o_inserted, lastscanned,
                                        path, filename)
                                if not options.quiet:
                                    print "Existing file updated: %s, %s" % (filename.encode(enc, 'replace'), path.encode(enc, 'replace'))
                                if options.verbose:
                                    print "UPDATE: " + str(tags)
                                c.execute("""update tags set
                                             id2=?, title=?, artist=?, album=?,
                                             genre=?, track=?, year=?,
                                             albumartist=?, composer=?, codec=?,
                                             length=?, size=?,
                                             created=?,
                                             discnumber=?, comment=?,
                                             folderart=?, trackart=?,
                                             bitrate=?, samplerate=?, 
                                             bitspersample=?, channels=?, mime=?,
                                             lastmodified=?, scannumber=?, 
                                             folderartid=?, trackartid=?, 
                                             inserted=?, lastscanned=?  
                                             where path=? and filename=?""", 
                                             tags)
                        except sqlite3.Error, e:
                            print "Error inserting/updating file tags:", e.args[0]

            except KeyboardInterrupt: 
                raise
            except Exception, err:
                print str(err)
                
    if options.database:

        db.commit()

        # now look for tag entries for this path that we didn't encounter - they must have been deleted or moved so flag for deletion
        try:
            scanpathlike = "%s%s" % (scanpath, '%')
            c2.execute("""select * from tags where scannumber != ? and path like ?""",
                        (scannumber, scanpathlike))
            for crow in c2:
                lastscanned = time.time()
                # get data
                o_id, o_id2, o_title, o_artist, o_album, \
                o_genre, o_track, o_year, \
                o_albumartist, o_composer, o_codec,  \
                o_length, o_size,  \
                o_created, o_path, o_filename,  \
                o_discnumber, o_comment,  \
                o_folderart, o_trackart,  \
                o_bitrate, o_samplerate,  \
                o_bitspersample, o_channels, o_mime,  \
                o_lastmodified, o_upnpclass, o_scannumber,  \
                o_folderartid, o_trackartid,  \
                o_inserted, o_lastscanned = crow
                # check if we have matched a partial path
                if scanpath != o_path:
                    if o_path[len(scanpath)] != os.sep:
                        continue
                # create audit records
                tags = (o_id, o_id2,
                        o_title, o_artist, o_album,
                        o_genre, o_track, o_year,
                        o_albumartist, o_composer, o_codec, 
                        o_length, o_size, 
                        o_created, o_path, o_filename, 
                        o_discnumber, o_comment, 
                        o_folderart, o_trackart, 
                        o_bitrate, o_samplerate, 
                        o_bitspersample, o_channels, o_mime, 
                        o_lastmodified, o_upnpclass, scannumber,
                        o_folderartid, o_trackartid,
                        o_inserted, o_lastscanned)
                # pre
                dtags = tags + (0, 'D')
                c.execute("""insert into tags_update values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""", dtags)
                # post
                dtags = cleartags(tags, lastscanned=lastscanned)
                dtags += (1, 'D')
                c.execute("""insert into tags_update values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""", dtags)
                # delete record from tags
                if not options.quiet:
                    print "Existing file not found: %s, %s" % (o_filename.encode(enc, 'replace'), o_path.encode(enc, 'replace'))
                if options.verbose:
                    print "DELETE: " + str(tags)
                c.execute("""delete from tags where id=?""", (o_id,))

        except sqlite3.Error, e:
            print "Error processing deletions:", e.args[0]

        # complete
        db.commit()
        c.close()
        c2.close()

def generate_subset(options, sourcedatabase, targetdatabase, where):

    if not options.quiet:
        print "Generating..."
    if options.database:

        db = sqlite3.connect(targetdatabase)
        db.execute("PRAGMA synchronous = 0;")
        c = db.cursor()
    
        if sourcedatabase != targetdatabase:
            # we are generating a new database, so attach to old and extract the data we need
            c.execute("attach ? as old", (sourcedatabase, ))
            # copy selected tags into new database
            statement = """insert into tags select * from old.tags %s""" % where
            print statement
            c.execute(statement) 
            # copy associated art
            statement = """insert into art select distinct old.art.id, old.art.artpath from old.art, tags where tags.folderartid = old.art.id or tags.trackartid = old.art.id"""
            c.execute(statement) 

        c.execute('''insert into scans values (?,?)''', (None, "generated"))
        scannumber = c.lastrowid
        if not options.quiet:
            print "Scannumber: %d" % scannumber

        lastscanned = time.time()

        try:
            statement = """insert into tags_update 
                           select id, '',
                           '', '', '',
                           '', '', '',
                           '', '', '', 
                           '', '', 
                           '', path, filename, 
                           '', '', 
                           '', '', 
                           '', '',
                           '', '', '', 
                           '', '', '%s',
                           '', '', 
                           '', '%f',
                           '0', 'I' from tags %s""" % (scannumber, lastscanned, where)
            c.execute(statement) 
            statement = """insert into tags_update 
                           select id, id2,
                           title, artist, album,
                           genre, track, year,
                           albumartist, composer, codec, 
                           length, size, 
                           created, path, filename, 
                           discnumber, comment, 
                           folderart, trackart, 
                           bitrate, samplerate, 
                           bitspersample, channels, mime, 
                           lastmodified, upnpclass, '%s',
                           folderartid, trackartid, 
                           inserted, '%f', 
                           '1', 'I' from tags %s""" % (scannumber, lastscanned, where)
            c.execute(statement) 
        except sqlite3.Error, e:
            print "Error generating file tags:", e.args[0]

        db.commit()
        c.close()


def cleartags(tags, lastscanned=''):
    id, id2, \
    title, artist, album, \
    genre, track, year, \
    albumartist, composer, codec, \
    length, size, \
    created, path, filename, \
    discnumber, comment, \
    folderart, trackart, \
    bitrate, samplerate, \
    bitspersample, channels, mime, \
    lastmodified, upnpclass, scannumber, \
    folderartid, trackartid, \
    inserted, o_lastscanned = tags
    tags = (id, '',
            '', '', '',
            '', '', '',
            '', '', '', 
            '', '', 
            '', path, filename, 
            '', '', 
            '', '', 
            '', '',
            '', '', '', 
            '', '', scannumber,
            '', '',
            '', lastscanned)
    return tags

def encodeunicode(data):
    if isinstance(data, str):
        return unicode(data)
    if isinstance(data, ASFUnicodeAttribute):   # hack for issue with asf type in mutagen
        return data.__str__()
    elif isinstance(data, dict):
        return dict(map(encodeunicode, data.iteritems()))
    elif isinstance(data, (list, tuple, set, frozenset)):
        return type(data)(map(encodeunicode, data))
    else:
        return data

def get_folderart(files):
    '''
        check through files found for folderart
    '''
    flist = {}
    for f in files:
        ff, ex = os.path.splitext(f.lower())
        if ex in artextns:
            if ff == 'folder' or ff == 'cover':
                flist[ff] = f
            elif ff.startswith('albumart') and ff.endswith('large'):
                flist['albumart'] = f
            elif ff.endswith('front'):
                flist['front'] = f
    if not flist:
        return None
    else:
        if 'folder' in flist.keys():
            return flist['folder']
        elif 'cover' in flist.keys():
            return flist['cover']
        elif 'albumart' in flist.keys():
            return flist['albumart']
        elif 'front' in flist.keys():
            return flist['front']

def check_database_exists(database):
    ''' 
        create database if it doesn't already exist
        if it exists, create table if it doesn't exist
        return abs path
    '''
    if not os.path.isabs(database):
        database = os.path.join(os.getcwd(), database)
    create_database(database)
    return database

def create_database(database):
    db = sqlite3.connect(database)
    c = db.cursor()
    try:
        # scans - unique id for each scan
        c.execute('SELECT count(*) FROM sqlite_master WHERE type="table" AND name="scans"')
        n, = c.fetchone()
        if n == 0:
            c.execute('''create table scans (id integer primary key autoincrement,
                                             scanpath text)
                      ''')
            c.execute('''create unique index inxScans on scans (id)''')
    
        # art - unique id for each piece of album art
        c.execute('SELECT count(*) FROM sqlite_master WHERE type="table" AND name="art"')
        n, = c.fetchone()
        if n == 0:
            c.execute('''create table art (id integer primary key autoincrement,
                                           artpath text)
                      ''')
            c.execute('''create unique index inxArt on art (id)''')
            c.execute('''create unique index inxArtArtpath on art (artpath)''')
    
        # tags - contain all detail from tags
        c.execute('SELECT count(*) FROM sqlite_master WHERE type="table" AND name="tags"')
        n, = c.fetchone()
        if n == 0:
            c.execute('''create table tags (id text, id2 text,
                                            title text, artist text, album text,
                                            genre text, track text, year text,
                                            albumartist text, composer text, codec text,
                                            length text, size text,
                                            created text, path text, filename text,
                                            discnumber text, comment text, 
                                            folderart text, trackart text,
                                            bitrate text, samplerate text, 
                                            bitspersample text, channels text, mime text,
                                            lastmodified text, upnpclass text, 
                                            scannumber integer, folderartid text, trackartid text,
                                            inserted text, lastscanned text)
                      ''')
            c.execute('''create unique index inxTagsPathFile on tags (path, filename)''')
            c.execute('''create unique index inxTags on tags (id)''')
            c.execute('''create index inxTagsScannumber on tags (scannumber)''')

        # tags_update - pre and post data from tags around an update
        c.execute('SELECT count(*) FROM sqlite_master WHERE type="table" AND name="tags_update"')
        n, = c.fetchone()
        if n == 0:
            c.execute('''create table tags_update (id text, id2 text,
                                                   title text, artist text, album text,
                                                   genre text, track text, year text,
                                                   albumartist text, composer text, codec text,
                                                   length text, size text,
                                                   created text, path text, filename text,
                                                   discnumber text, comment text, 
                                                   folderart text, trackart text,
                                                   bitrate text, samplerate text, 
                                                   bitspersample text, channels text, mime text,
                                                   lastmodified text, upnpclass text,
                                                   scannumber integer, folderartid text, trackartid text,
                                                   inserted text, lastscanned text,
                                                   updateorder integer, updatetype text)
                      ''')
#            c.execute('''create unique index inxTagsDeletePathFile on tags_update (path, filename, scannumber)''')
            c.execute('''create unique index inxTagsDeleteIdScanUpdate on tags_update (id, scannumber, updateorder)''')
            c.execute('''create unique index inxTagsDeleteScanUpdateId on tags_update (scannumber, updatetype, id, updateorder)''')
#            c.execute('''create index inxTagsDelete on tags_update (id)''')
            c.execute('''create index inxTagsDeleteScannumber on tags_update (scannumber)''')
    except sqlite3.Error, e:
        print "Error creating database:", database.encode(enc, 'replace')
        print e
    db.commit()
    c.close()

def delete_updates(database):
    db = sqlite3.connect(database)
    c = db.cursor()
    try:
        c.execute('''delete from tags_update''')
    except sqlite3.Error, e:
        print "Error deleting from tags_update:", table, e
    db.commit()
    c.close()
    
def process_command_line(argv):
    """
        Return a 2-tuple: (settings object, args list).
        `argv` is a list of arguments, or `None` for ``sys.argv[1:]``.
    """
    if argv is None:
        argv = sys.argv[1:]

    # initialize parser object
    parser = optparse.OptionParser(
        formatter=optparse.TitledHelpFormatter(width=78),
        add_help_option=None)

    # options
    parser.add_option("-d", "--database", dest="database", type="string", 
                      help="write tags to DATABASE", action="store",
                      metavar="DATABASE")
    parser.add_option("-x", "--extract", dest="extract", type="string", 
                      help="write extract to DATABASE", action="store",
                      metavar="EXTRACT")
    parser.add_option("-w", "--where", dest="where", type="string", 
                      help="where clause to extract on", action="store",
                      metavar="WHERE")
    parser.add_option("-e", "--exclude", dest="exclude", type="string",
                      action="append", metavar="EXCLUDE",
                      help="exclude foldernames containing this string")
    parser.add_option("-r", "--regenerate",
                      action="store_true", dest="regenerate", default=False,
                      help="regenerate update records")
    parser.add_option("-q", "--quiet",
                      action="store_true", dest="quiet", default=False,
                      help="don't print status messages to stdout")
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="print verbose status messages to stdout")
#    parser.add_option("-c", "--ctime",
#                      action="store_true", dest="ctime", default=False,
#                      help="user ctime rather than mtime to detect file changes")
    parser.add_option('-h', '--help', action='help',
                      help='Show this help message and exit.')
    settings, args = parser.parse_args(argv)
    return settings, args

def main(argv=None):
    options, args = process_command_line(argv)
    if options.database:
        database = check_database_exists(options.database)
        if not options.quiet:
            print "Database: ", database.encode(enc, 'replace')
    else:
        database = None
    if options.regenerate:
        delete_updates(database)
        generate_subset(options, database, database, '')
    elif options.extract and options.where:
        newdatabase = check_database_exists(options.extract)
        generate_subset(options, database, newdatabase, options.where)
    else:
        for path in args: 
            if path.endswith(os.sep): path = path[:-1]
            process_dir(path, options, database)
    return 0

if __name__ == "__main__":
    status = main()
    sys.exit(status)

